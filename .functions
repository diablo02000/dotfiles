# Run db client like psql or mysql  and store
# console output to log file.
function dbClientTrace(){
  # Get db client tool name
  local DB_CLIENT_TOOL_NAME="${1}"
  shift

  # Get username and database name
  # from command arguments
  POSITIONAL_ARGS=()

  while [[ $# -gt 0 ]]; do
    case $1 in
      -U|-u)
        DB_USERNAME="$2"
        shift
        shift
        ;;
      -d|-D)
        DB_NAME="$2"
        shift
        shift
        ;;
      *)
        POSITIONAL_ARGS+=("$1")
        shift
        ;;
    esac
  done

  set -- "${POSITIONAL_ARGS[@]}"

  # Create path to log file
  local DB_CLIENT_LOG_FILE="$(printf "%s/%s-%s-%s-%d.log" "/var/log/db_client" ${DB_CLIENT_TOOL_NAME} ${DB_USERNAME} ${DB_NAME} $(date +%s))"

  # Build client cmd
  if [[ ${DB_CLIENT_TOOL_NAME} == "mysql" ]];
  then
    \mysql $@ -u "${DB_USERNAME}" -D "${DB_NAME}" --tee="${DB_CLIENT_LOG_FILE}"
  elif [[ ${DB_CLIENT_TOOL_NAME} == "psql" ]];
  then
    \psql $@ -U "${DB_USERNAME}" -d "${DB_NAME}" -L "${DB_CLIENT_LOG_FILE}"
  else
    echo -e "${DB_CLIENT_TOOL_NAME} not manage"
  fi
}

# Push gitlab pipeline YAML file to
# Gitlab Linter API endpoint for syntax
# verification
function gitlabCiLinter(){
  # Get path to gitlab-ci file.
  local gitlab_ci_file="${1:=.gitlab-ci.yml}"

  if [[ -z $GITLAB_HOST ]] || [[ -z $GITLAB_PRIVATE_TOKEN ]];
  then
    echo -e "'GITLAB_HOST' or 'GITLAB_PRIVATE_TOKEN' variables not define."
  else
    # Send gitlab-ci file content to API.
    jq --null-input --arg yaml "$(<${gitlab_ci_file})" '.content=$yaml' \
    | curl --header "PRIVATE-TOKEN: ${GITLAB_PRIVATE_TOKEN}" \
          --header 'Content-Type: application/json' \
          "https://${GITLAB_HOST}/api/v4/ci/lint?include_merged_yaml=true" --data @- | jq
  fi
}

# =============================================
# Function: Generate .gitignore file
# Description: Fetches a .gitignore template for specified languages/tools from gitignore.io
# Usage: gi <language/tool1> <language/tool2> ...
# Source: https://docs.gitignore.io/install/command-line
# =============================================
gi() {
    # Use curl to fetch the .gitignore template silently (-s), follow redirects (-L),
    # and suppress the progress meter but show errors (-w n)
    curl -sLw n https://www.toptal.com/developers/gitignore/api/$@
}

# =============================================
# Function: Select and copy emoji to clipboard
# Description: Fetches a list of emojis, lets the user select one using fzf, and copies it to the clipboard
# Usage: emojis
# =============================================
emojis() {
    local emojis_url="https://git.io/JXXO7"

    # Fetch the emoji list, use fzf for interactive selection
    local emoji_selected
    emoji_selected="$(curl -sL "${emojis_url}" | fzf --height=40%)" || return 1

    # Extract the emoji icon (first field, space-delimited)
    local emoji
    emoji="$(cut -d ' ' -f1 <<< "${emoji_selected}")"

    # Copy the emoji to the clipboard using wl-copy (Wayland) or xclip (X11)
    if command -v wl-copy >/dev/null; then
        wl-copy "${emoji}"
    elif command -v xclip >/dev/null; then
        xclip -selection clipboard <<< "${emoji}"
    else
        echo "‚ùå Error: No clipboard utility found (wl-copy or xclip required)."
        return 1
    fi

    echo -e "üìã Emoji stored in clipboard: ${emoji}"
}

# =============================================
# Function: Clone repository and switch to project directory
# Description: Clones a repository using git-grab and changes to the local project directory.
#              Displays the output of git-grab and the directory change status.
# Usage: ggb <repository_url>
# =============================================
ggb() {
    local url="${1}"
    local git_grab_output
    local project_directory

    # Clone the repository using git-grab and display the output
    git_grab_output=$(git-grab "${url}" | tee /dev/tty)

    # Extract the project directory from the git-grab output
    project_directory=$(grep -i "Grabbed" <<<"${git_grab_output}" | awk '{print $NF}')

    # Check if the project directory was extracted successfully
    if [[ -z "${project_directory}" ]]; then
        echo -e "‚ùå Error: Could not determine the project directory from git-grab output."
        return 1
    fi

    # Attempt to change to the project directory
    echo -e "‚ñ∂Ô∏è Changing directory to '${project_directory}'"
    cd "${project_directory}" || {
        echo -e "‚ùå Error: Failed to change directory to '${project_directory}'"
        return 1
    }
}

# =============================================
# Function: Visualize file content with appropriate tool
# Description: Opens a file using the best available visualization tool
#              based on its extension (e.g., `glow` for Markdown, `bat` for others).
# Usage: viz <file_path>
# =============================================
viz() {
    local file="${1}"
    local binary
    local file_ext

    # Check if the file exists
    if [[ ! -f "${file}" ]]; then
        echo -e "‚ùå Error: File '${file}' does not exist."
        return 1
    fi

    # Extract file extension
    file_ext="${file##*.}"

    # Select the appropriate binary based on file extension
    case "${file_ext}" in
        "md")
            binary="glow" ;;
        "json")
            binary="jq" ;;
        "yaml"|"yml")
            binary="yq" ;;
        *)
            binary="bat" ;;
    esac

    # Check if the selected binary is available
    if ! command -v "${binary}" >/dev/null 2>&1; then
        echo -e "‚ùå Error: '${binary}' is not installed."
        return 1
    fi

    # Visualize the file
    if [[ "${binary}" == "jq" ]] || [[ "${binary}" == "yq" ]]; then
        "${binary}" < "${file}"
    else
        "${binary}" "${file}"
    fi
}
